/*! (c) Andrea Giammarchi */
const{is:s}=Object;let t;const e=s=>{const e=t;t=e||[];try{if(s(),!e)for(const s of t)s()}finally{t=e}};class i{constructor(s){this._=s}then(){return this.value}toJSON(){return this.value}toString(){return this.value}valueOf(){return this.value}}const h=({e:s})=>{for(const t of s)t.$=!0,h(t)};let n;const o=({c:s})=>{if(s.size){const e=n;n=e||[];for(const t of s)t.$||(t.$=!0,t.f?(n.push(t),h(t)):o(t.s));try{if(!e)for(const s of n)t?t.push((()=>{s.value})):s.value}finally{n=e}}};let c,r;const l=s=>{for(const t of s.r)t.c.delete(s);s.r.clear()};class u extends i{constructor(s,t,e){super(s),this.f=!1,this.$=!1,this.s=null,this.r=new Set,this.o=e,this.v=t}get value(){const s=c,t=r;try{c=this,r=this.r,this.s?this.$&&(l(this),this.s.value=this._(this.s._)):this.s=new w(this._(this.v),this.v=this.o)}finally{this.$=!1,c=s,r=t}return this.s.value}}const a={async:!1,equals:!0},f=(s,t,e=a)=>new u(s,t,e);let v;const p=()=>{},y=s=>{for(const t of s)t.stop()};class _ extends u{constructor(s,t,e){super(s,t,e).f=!0,this.i=0,this.a=!!e.async,this.m=!0,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const s=v;v=this,this.i=0;const{length:t}=this.e;super.value,this.i<t&&y(this.e.splice(this.i));for(const{value:s}of this.e);v=s}stop(){this.s&&(l(this),this.s.c.clear(),this.s=this.r=null),this._=p,this.e.length&&y(this.e.splice(0))}}const d=(s,t,e=a)=>{let i;if(v){const{i:h,e:n}=v;h!==n.length&&n[h]._===s||(n[h]=new _(s,t,e)),i=n[h],v.i++}else(i=new _(s,t,e)).value;return()=>{i.stop()}},g=()=>!1;class w extends i{constructor(t,{equals:e}){super(t),this.c=new Set,this.s=!0===e?s:e||g}peek(){return this._}get value(){return c&&(this.c.add(c),r.add(this)),this._}set value(s){this.s(this._,s)||(this._=s,o(this))}}const $=(s,t=a)=>new w(s,t);export{i as Signal,e as batch,f as computed,d as effect,$ as signal};
