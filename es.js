/*! (c) Andrea Giammarchi */
const{is:t}=Object;let s;const e=t=>{const e=s;s=e||[];try{if(t(),!e)for(const t of s)t()}finally{s=e}};class i{constructor(t){this._=t}toJSON(){return this.value}toString(){return this.value}valueOf(){return this.value}}const n=({e:t})=>{for(const s of t)s.$=!0,n(s)};let o;const c=({c:t})=>{if(t.size){const e=o;o=e||new Set;for(const s of t){const e=s.deref();e?e.$||(e.$=!0,e instanceof f?(o.add(e),n(e)):c(e.s)):t.delete(s)}try{if(!e)for(const t of o)s?s.push((()=>{t.value})):t.value}finally{o=e}}};let r;class h extends i{constructor(t){super(t),this.$=!1,this.s=void 0}get value(){if(!this.s){const t=r;r=new Set;try{this.s=new y(this._());const s=new WeakRef(this);for(const t of r)t.c.add(s)}finally{r=t}}if(this.$)try{this.s.value=this._()}finally{this.$=!1}return this.s.value}}const l=t=>new h(t);let a;const u=()=>{};class f extends h{constructor(t,s){super(t),this.i=0,this.a=s,this.m=s,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const t=a;(a=this).i=0,super.value,a=t}stop(){this._=this.sync=this.async=u;for(const t of this.e.splice(0))t.stop()}}const v=(t,s=!1)=>{let e;if(a){const{i:i,e:n}=a;e=n[i]||(n[i]=new f(t,s)),a.i++}else e=new f(t,s);return e.value,()=>{e.stop()}};class y extends i{constructor(t){super(t).c=new Set}peek(){return this._}get value(){return r&&r.add(this),this._}set value(s){t(s,this._)||(this._=s,c(this))}}const d=t=>new y(t);export{i as Signal,e as batch,l as computed,v as effect,d as signal};
