/*! (c) Andrea Giammarchi */
const{is:t}=Object;let s;const e=t=>{const e=s;s=e||[];try{if(t(),!e)for(const t of s)t()}finally{s=e}};class i{constructor(t){this._=t}then(){return this.value}toJSON(){return this.value}toString(){return this.value}valueOf(){return this.value}}const h=({e:t})=>{for(const s of t)s.$=!0,h(s)};let n;const o=({c:t})=>{if(t.size){const e=n;n=e||[];for(const s of t)s.$||(s.$=!0,1===s.b?(n.push(s),h(s)):o(s.s));try{if(!e)for(const t of n)s?s.push((()=>{t.value})):t.value}finally{n=e}}};let c,r;const l=t=>{for(const s of t.r)s.c.delete(t);t.r.clear()};class u extends i{constructor(t,s){super(t),this.b=s,this.$=!1,this.s=null,this.r=new Set}get value(){const t=c,s=r;try{c=this,r=this.r,this.s?this.$&&(l(this),this.s.value=this._()):this.s=new d(this._())}finally{this.$=!1,c=t,r=s}return this.s.value}}const a=t=>new u(t,0);let f;const v=()=>{},p=t=>{for(const s of t)s.stop()};class y extends u{constructor(t,s){super(t,1),this.i=0,this.a=s,this.m=s,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const t=f;f=this,this.i=0;const{length:s}=this.e;super.value,this.i<s&&p(this.e.splice(this.i));for(const{value:t}of this.e);f=t}stop(){this.s&&(l(this),this.s.c.clear(),this.s=this.r=null),this._=v,this.e.length&&p(this.e.splice(0))}}const _=(t,s=!1)=>{let e;if(f){const{i:i,e:h}=f;i!==h.length&&h[i]._===t||(h[i]=new y(t,s)),e=h[i],f.i++}else(e=new y(t,s)).value;return()=>{e.stop()}};class d extends i{constructor(t){super(t).c=new Set}peek(){return this._}get value(){return c&&(this.c.add(c),r.add(this)),this._}set value(s){t(s,this._)||(this._=s,o(this))}}const g=t=>new d(t);export{i as Signal,e as batch,a as computed,_ as effect,g as signal};
