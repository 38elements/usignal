/*! (c) Andrea Giammarchi */
let t;const s=s=>{const e=t;t=new Set;try{s();for(const s of t)e?e.add(s):s()}finally{t=e}};let e;const r=t=>{const s=e;e=t;try{t()}finally{e=s}};class n{constructor(t){this._=t}toString(){return this.value}valueOf(){return this.value}}let o;class i extends n{constructor(t){super(t),this.c=void 0,this.v=void 0}get value(){return this.c||(this.c=()=>{const t=o;o=this.c;try{this.v=this._()}finally{o=t}})(),this.v}set value(t){throw new Error("computed are read-only")}}const c=t=>new i(t);class h extends n{constructor(t){super(t),this.c=new Set,this.e=new Set}get value(){return o&&this.c.add(o),e&&this.e.add(e),this._}set value(s){if(this._!==s){this._=s;for(const t of this.c)t();for(const s of this.e)t?t.add(s):s()}}peek(){return this._}}const l=t=>new h(t);export{n as Signal,s as batch,c as computed,r as effect,l as signal};
