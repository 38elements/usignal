/*! (c) Andrea Giammarchi */
let t;const s=s=>{const e=t;t=new Set;try{s();for(const s of t)e?e.add(s):s()}finally{t=e}};let e;const r=t=>{const s=e;e=t;try{t()}finally{e=s}};class n{constructor(t){this._=t}}let i;class o extends n{constructor(t){super(t),this.c=void 0,this.v=void 0}get value(){return this.c||(this.c=()=>{const t=i;i=this.c;try{this.v=this._()}finally{i=t}})(),this.v}set value(t){throw new Error("computed are read-only")}toString(){return this.value}valueOf(){return this.value}}const c=t=>new o(t);class h extends n{constructor(t){super(t),this.c=new Set,this.e=new Set}get value(){return i&&this.c.add(i),e&&this.e.add(e),this._}set value(s){if(this._!==s){this._=s;for(const t of this.c)t();for(const s of this.e)t?t.add(s):s()}}peek(){return this._}toString(){return this._}valueOf(){return this._}}const l=t=>new h(t);export{n as Signal,s as batch,c as computed,r as effect,l as signal};
